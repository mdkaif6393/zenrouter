name: Test

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for coverage-badge-action to update gh-pages
      pull-requests: write  # Required for commenting on PRs
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for coverage-badge-action

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true

      - name: Install dependencies
        run: flutter pub get
        working-directory: .

      - name: Verify formatting
        run: dart format --set-exit-if-changed .
        continue-on-error: false

      - name: Analyze code
        run: flutter analyze
        continue-on-error: false

      - name: Run tests with coverage (zenrouter)
        run: flutter test --coverage
        working-directory: packages/zenrouter
        continue-on-error: false

      - name: Run tests with coverage (zenrouter_file_generator)
        run: flutter test --coverage
        working-directory: packages/zenrouter_file_generator
        continue-on-error: false

      - name: Convert coverage to json-summary for each package
        run: |
          # Convert lcov to json-summary format for each package
          mkdir -p coverage
          python3 << 'EOF'
          import json
          import os
          import re
          
          packages = ['zenrouter', 'zenrouter_file_generator']
          
          def parse_lcov_file(lcov_file):
              """Parse lcov file and return total/covered lines"""
              if not os.path.exists(lcov_file):
                  return 0, 0
              
              with open(lcov_file, 'r') as f:
                  content = f.read()
              
              # Extract LF (lines found) and LH (lines hit) from summary
              # LCOV format: each file has LF/LH, and there's a summary at the end
              lf_matches = re.findall(r'LF:(\d+)', content)
              lh_matches = re.findall(r'LH:(\d+)', content)
              
              # Use the last entry which is typically the summary
              total_lines = int(lf_matches[-1]) if lf_matches else 0
              covered_lines = int(lh_matches[-1]) if lh_matches else 0
              
              return total_lines, covered_lines
          
          # Process each package separately
          all_coverages = {}
          total_all_lines = 0
          total_all_covered = 0
          
          for pkg in packages:
              lcov_file = f'packages/{pkg}/coverage/lcov.info'
              total_lines, covered_lines = parse_lcov_file(lcov_file)
              
              if total_lines > 0:
                  pct = round((covered_lines / total_lines * 100), 2)
                  
                  # Create json-summary for this package
                  summary = {
                      'total': {
                          'lines': {
                              'total': total_lines,
                              'covered': covered_lines,
                              'skipped': 0,
                              'pct': pct
                          }
                      }
                  }
                  
                  coverage_file = f'coverage/{pkg}-coverage-summary.json'
                  with open(coverage_file, 'w') as f:
                      json.dump(summary, f, indent=2)
                  
                  print(f'{pkg}: {covered_lines}/{total_lines} lines ({pct}%)')
                  all_coverages[pkg] = summary
                  total_all_lines += total_lines
                  total_all_covered += covered_lines
          
          # Create overall summary
          if total_all_lines > 0:
              overall_pct = round((total_all_covered / total_all_lines * 100), 2)
              overall_summary = {
                  'total': {
                      'lines': {
                          'total': total_all_lines,
                          'covered': total_all_covered,
                          'skipped': 0,
                          'pct': overall_pct
                      }
                  }
              }
              
              with open('coverage/coverage-summary.json', 'w') as f:
                  json.dump(overall_summary, f, indent=2)
              
              print(f'Overall: {total_all_covered}/{total_all_lines} lines ({overall_pct}%)')
          EOF
        continue-on-error: true

      - name: Update Coverage Badge (zenrouter)
        if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: we-cli/coverage-badge-action@main
        with:
          coverage_file: coverage/zenrouter-coverage-summary.json
          badge_name: coverage-zenrouter

      - name: Update Coverage Badge (zenrouter_file_generator)
        if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: we-cli/coverage-badge-action@main
        with:
          coverage_file: coverage/zenrouter_file_generator-coverage-summary.json
          badge_name: coverage-zenrouter_file_generator

      - name: Update Coverage Badge (overall)
        if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: we-cli/coverage-badge-action@main
        with:
          coverage_file: coverage/coverage-summary.json

      - name: Comment PR Coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let body = '## ðŸ“Š Coverage Report\n\n';
            let hasCoverage = false;
            
            const packages = [
              { name: 'zenrouter', file: 'coverage/zenrouter-coverage-summary.json' },
              { name: 'zenrouter_file_generator', file: 'coverage/zenrouter_file_generator-coverage-summary.json' },
              { name: 'Overall', file: 'coverage/coverage-summary.json' }
            ];
            
            for (const pkg of packages) {
              if (fs.existsSync(pkg.file)) {
                const coverage = JSON.parse(fs.readFileSync(pkg.file, 'utf8'));
                const pct = coverage.total.lines.pct;
                const covered = coverage.total.lines.covered;
                const total = coverage.total.lines.total;
                
                body += `**${pkg.name}:** ${covered}/${total} lines (${pct}%)\n`;
                hasCoverage = true;
              }
            }
            
            if (hasCoverage) {
              body += '\nCoverage calculated for this PR branch.';
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

